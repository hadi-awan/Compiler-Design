/* Generated By:JavaCC: Do not edit this line. HLEval.java Version 7.0.9 */

import java.util.TreeSet;
import java.util.ArrayList;
import java.util.List;

public class HLEval implements HLVisitor{
  
  public Object defaultVisit(SimpleNode node, Object data) throws Exception{
    node.childrenAccept(this, data);
    return data;
  }

  public Object visit(SimpleNode node, Object data) throws Exception{
    return defaultVisit(node, data);
  }

  public Object visit(ASTbody node, Object data) throws Exception{
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  node.jjtGetChild(i).jjtAccept(this, data);
	  }
	  return null;
  }

  public Object visit(ASTclause node, Object data) throws Exception{
	  Object result = null;
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  result = node.jjtGetChild(i).jjtAccept(this, data);
	  }
	  return result;
  }

  // Handles variable declarations, setting default values based on type
  public Object visit(ASTvar_decl node, Object data) throws Exception{
	  // Process each identifier in the declaration list
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  SimpleNode idNode = (SimpleNode)node.jjtGetChild(i);
		  if (idNode instanceof ASTidentifier) {
			  Integer idKey = (Integer)idNode.jjtGetValue();
			  String varName = IdentifierToken.getName(idKey);
			  String varType;
			  Object defaultValue;

			  // Determine type and default value based on naming convention
			  if (varName.startsWith("#")) {	// Boolean variables start with #
				  varType = "typebool";
				  defaultValue = Boolean.FALSE;
			  }
			  else if (Character.isUpperCase(varName.charAt(0))) {	// Set variables start with uppercase
				  varType = "typeset";
				  defaultValue = new HLSet();
			  }
			  else {	// Number variables are default
				  varType = "typenum";
				  defaultValue = new HLNumber(0);
			  }

			  // Create symbol table entry with determined type and default value
			  HLSymbTab.declareVariable(idKey, varType, defaultValue);
		  }
	  }
	  return null;
  }

  // Processes function declarations, storing function info in symbol table
  public Object visit(ASTfn_decl node, Object data) throws Exception{
          // Extract function name identifier
	  ASTidentifier fnIdNode = (ASTidentifier)node.jjtGetChild(0);
          Integer fnKey = (Integer)fnIdNode.jjtGetValue();

          // Collect parameter list if present
	  List<Integer> paramKeys = new ArrayList<>();
          if (node.jjtGetNumChildren() > 2) {
                  SimpleNode paramList = (SimpleNode)node.jjtGetChild(1);
                  for (int i = 0; i < paramList.jjtGetNumChildren(); i++) {
                          ASTidentifier paramId = (ASTidentifier)paramList.jjtGetChild(i);
                          paramKeys.add((Integer)paramId.jjtGetValue());
                  }
          }       

          // Get function body and current scope
	  SimpleNode body = (SimpleNode)node.jjtGetChild(node.jjtGetNumChildren() - 1);
	  HLActivation definitionScope = HLActivation.getCurrentActivation();

          // Register function in symbol table
	  HLSymbTab.declareFunction(fnKey, body, paramKeys, definitionScope);
          return null;
  }

  public Object visit(ASTident_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }

  // Processes function calls with return values
  public Object visit(ASTfn_call node, Object data) throws Exception{
	  // Get function identifier and lookup function info
	  ASTidentifier fnIdNode = (ASTidentifier)node.jjtGetChild(0);
	  Integer fnKey = (Integer)fnIdNode.jjtGetValue();
	  HLSymbTab.Function fn = HLSymbTab.getFunction(fnKey);

	  // Evaluate parameters in current scope before creating new one
	  List<Object> argValues = new ArrayList<>();
	  if (node.jjtGetNumChildren() > 1) {
		  SimpleNode argList = (SimpleNode)node.jjtGetChild(1);
		  for (int i = 0; i < argList.jjtGetNumChildren(); i++) {
			  Object argValue = argList.jjtGetChild(i).jjtAccept(this, data);
			  argValues.add(argValue);
		  }
	  }

	  // Create new activation with the function's definition scope as lexical parent
	  HLActivation newActivation = new HLActivation(fn.definitionScope);

	  try {
		  // Bind parameters to values in new scope
		  for (int i = 0; i < fn.paramKeys.size(); i++) {
			  Integer paramKey = fn.paramKeys.get(i);
			  Object paramValue = argValues.get(i);
			  // Create a new entry in the current activation for this parameter
			  HLSymbTab paramEntry = new HLSymbTab(paramKey, inferType(paramValue));
			  paramEntry.setValue(paramValue);
			  newActivation.addVariable(paramEntry);
		  }

		  // Execute function body
		  try {
			  Object result = fn.body.jjtAccept(this, data);
			  if (result instanceof ReturnException) {
				  return ((ReturnException)result).getReturnValue();
			  }
			  return result;
		  }
		  catch (ReturnException re) {
			  return re.getReturnValue();
		  }
	  }
	  finally {
		  newActivation.pop();
	  }
  }

  // Processes boolean function calls
  public Object visit(ASTboolean_call node, Object data) throws Exception{
	  // Get function identifier and verify function exists
	  ASTidentifier fnIdNode = (ASTidentifier)node.jjtGetChild(0);
	  Integer fnKey = (Integer)fnIdNode.jjtGetValue();
	  HLSymbTab.Function fn = HLSymbTab.getFunction(fnKey);

	  // Create new activation record with function's definition scope as lexical parent
	  HLActivation newActivation = HLActivation.pushWithLexicalScope(fn.definitionScope);

	  try {
		  // Evaluate parameters in current scope
		  List<Object> argValues = new ArrayList<>();
		  if (node.jjtGetNumChildren() > 1) {
			  SimpleNode argList = (SimpleNode)node.jjtGetChild(1);
			  for (int i = 0; i < argList.jjtGetNumChildren(); i++) {
				  Object argValue = argList.jjtGetChild(i).jjtAccept(this, data);
				  argValues.add(argValue);
			  }
		  }

		  // Bind parameters in new scope
		  for (int i = 0; i < fn.paramKeys.size(); i++) {
			  Integer paramKey = fn.paramKeys.get(i);
			  Object paramValue = argValues.get(i);
			  String type;
                          if (paramValue instanceof Boolean) type = "typebool";
                          else if (paramValue instanceof HLSet) type = "typeset";
                          else type = "typenum";
			  
			  HLSymbTab.declareVariable(paramKey, type, paramValue);
		  }

		  // Execute function body
		  try {
			  fn.body.jjtAccept(this, data);
			  return false;  // Default return for boolean functions
		  }
		  catch (ReturnException re) {
			  return re.getReturnValue();
		  }
	  }
	  finally {
		  newActivation.pop();
	  }
  }

  private String inferType(Object value) {
	  if (value instanceof Boolean) return "typebool";
	  if (value instanceof HLSet) return "typeset";
	  return "typenum";
  }

  public Object visit(ASTvalue_list node, Object data) throws Exception{
	  List<Object> values = new ArrayList<>();
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  Object value = node.jjtGetChild(i).jjtAccept(this, data);
		  values.add(value);
	  }
	  return values;
  }

  // Return statement visitor
  public Object visit(ASTReturn node, Object data) throws Exception{
	  Object returnValue = null;
	  if (node.jjtGetNumChildren() > 0) {
		  returnValue = node.jjtGetChild(0).jjtAccept(this, data);
	  }
	  throw new ReturnException(returnValue);
  }

  // Update assignment visitor
  public Object visit(ASTAssign node, Object data) throws Exception{
	  // Get identifier key from first child
	  ASTidentifier idNode = (ASTidentifier)node.jjtGetChild(0);
	  Integer idKey = (Integer)idNode.jjtGetValue();

	  // Get the current value
	  Object value = node.jjtGetChild(1).jjtAccept(this, data);

	  // Convert boolean literals to proper boolean values if needed
	  if (value instanceof String) {
		  String strValue = (String)value;
		  if (strValue.equals("#1")) {
			  value = Boolean.TRUE;
		  }
		  else if (strValue.equals("#0")) {
			  value = Boolean.FALSE;
		  }
	  }

	  HLSymbTab.assignVariable(idKey, value);
	  return null;
  }

  // Print statement evaluation
  public Object visit(ASTPrint node, Object data) throws Exception{
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  Object child = node.jjtGetChild(i).jjtAccept(this, data);
		  if (child instanceof Object[]) {
			  for (Object value : (Object[])child) {
				  printValue(value);
			  }
		  }
		  else {
			  printValue(child);
		  }
	  }

	  return null;
  }

  // Println statement evaluation (adds newline)
  public Object visit(ASTPrintln node, Object data) throws Exception{
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  Object child = node.jjtGetChild(i).jjtAccept(this, data);
		  if (child instanceof Object[]) {
			  for (Object value : (Object[])child) {
				  printValue(value);
			  }
		  }
		  else {
			  printValue(child);
		  }
	  }

	  System.out.println();
	  return null;
  }
  
  // Helper method for printing values
  private void printValue(Object value) {
	  if (value instanceof HLNumber) { System.out.print(((HLNumber)value).value); }
	  else if (value instanceof Boolean) { System.out.print(((Boolean)value) ? "true" : "false"); }
	  else if (value instanceof String) { System.out.print(value); }
	  else if (value instanceof HLSet) { System.out.print(value); }
  }
  
  public Object visit(ASTprint_list node, Object data) throws Exception{
	  Object[] values = new Object[node.jjtGetNumChildren()];

	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  values[i] = node.jjtGetChild(i).jjtAccept(this, data);
	  }
	  return values;
  }
  
  // If statement evaluation
  public Object visit(ASTIf node, Object data) throws Exception{
	  // Evaluate condition
	  Object condition = node.jjtGetChild(0) != null ? node.jjtGetChild(0).jjtAccept(this, data) : null;

	  // If condition is true, execute then branch
	  if (condition instanceof Boolean && (Boolean)condition) {
		  return node.jjtGetChild(1).jjtAccept(this, data);
	  }

	  // If condition is false and else exists, execute else branch
	  else if (node.jjtGetNumChildren() > 2) {
		  return node.jjtGetChild(2).jjtAccept(this, data);
	  }

	  return null;
  }
  
  public Object visit(ASTNULL node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  
  public Object visit(ASTFor node, Object data) throws Exception{
	  // Get the loop variable identifier
	  ASTidentifier idNode = (ASTidentifier)node.jjtGetChild(0);
	  Integer idKey = (Integer)idNode.jjtGetValue();

	  // Get the expression list node
	  SimpleNode exprList = (SimpleNode)node.jjtGetChild(1);

	  // Loop body is the last child
	  SimpleNode body = (SimpleNode)node.jjtGetChild(2);

	  // Process each expression in the list
	  for (int i = 0; i < exprList.jjtGetNumChildren(); i++) {
		  Object expr = exprList.jjtGetChild(i).jjtAccept(this, data);

		  if (expr instanceof HLSet) {
			  // For sets, iterate through their elements in order
			  TreeSet elements = ((HLSet)expr).getElements();
			  for (Object num: elements) {
				  // Assign current value to loop variable
				  HLSymbTab.assignVariable(idKey, num);
				  // Execute loop body
				  body.jjtAccept(this, data);
			  }
		  }
		  else if (expr instanceof HLNumber) {
			  // For single numbers, just execute once with that value
			  HLSymbTab.assignVariable(idKey, expr);
			  body.jjtAccept(this, data);
		  }
	  }

	  return null;
  }
  
  public Object visit(ASTexp_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  
  // Add While statement evaluation
  public Object visit(ASTWhile node, Object data) throws Exception{
	  while (true) {
		  // Evaluate condition
		  Object condition = node.jjtGetChild(0).jjtAccept(this, data);
		  if (!(condition instanceof Boolean) || !((Boolean)condition)) { break; }

		  // Execute body
		  node.jjtGetChild(1).jjtAccept(this, data);
	  }
	  return null;
  }

  public Object visit(ASTor node, Object data) throws Exception{
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  Boolean result = (Boolean)node.jjtGetChild(i).jjtAccept(this, data);
		  if (result) return true;
	  }
	  return false;
  }

  public Object visit(ASTand node, Object data) throws Exception{
	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  Boolean result = (Boolean)node.jjtGetChild(i).jjtAccept(this, data);
		  if (!result) return false;
	  }
	  return true;
  }

  public Object visit(ASTnot node, Object data) throws Exception{
	  Boolean result = (Boolean) node.jjtGetChild(0).jjtAccept(this, data);
	  return !result;
  }

  public Object visit(ASTTRUE node, Object data) throws Exception{
	  return true;
  }

  public Object visit(ASTFALSE node, Object data) throws Exception{
	  return false;
  }

  // Handles all comparisons including set operations
  public Object visit(ASTcomparison node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(2).jjtAccept(this, data);
	  String operator = node.jjtGetChild(1).toString();

	  // Number comparisons
	  if (left instanceof HLNumber && right instanceof HLNumber) {
		  HLNumber leftNum = (HLNumber)left;
		  HLNumber rightNum = (HLNumber)right;

		  switch (operator) {
			  case "LESS": return leftNum.isLessThan(rightNum);
		          case "GREATER": return leftNum.isGreaterThan(rightNum);
			  case "LESSEQ": return leftNum.isLessThanOrEqualTo(rightNum);
			  case "GREATEQ": return leftNum.isGreaterThanOrEqualTo(rightNum);
		          case "EQUAL": return leftNum.isEqualTo(rightNum);
		          case "NOTEQ": return !leftNum.isEqualTo(rightNum);
		  }
	  }

	  // Set comparisons
	  else if (left instanceof HLSet && right instanceof HLSet) {
		  HLSet leftSet = (HLSet)left;
		  HLSet rightSet = (HLSet)right;

		  switch(operator) {
			  case "LESS": return leftSet.isLessThan(rightSet);
		          case "LESSEQ": return leftSet.isLessThan(rightSet) || leftSet.isSame(rightSet);
		          case "GREATER": return rightSet.isLessThan(leftSet);
			  case "GREATEQ": return rightSet.isLessThan(leftSet) || leftSet.isSame(rightSet);
		          case "EQUAL": return leftSet.isSame(rightSet);
			  case "NOTEQ": return !leftSet.isSame(rightSet);
		  }
	  }

	  // Set membership operations
	  else if (left instanceof HLNumber && right instanceof HLSet) {
		  switch(operator) {
			  case "ISIN": return ((HLSet)right).contains((HLNumber)left);
			  case "NOTIN": return !((HLSet)right).contains((HLNumber)left);
		  }
	  }
	  return false;
  }

  public Object visit(ASTLESS node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);

	  if (left instanceof HLSet && right instanceof HLSet) {
		  return ((HLSet)left).isLessThan((HLSet)right);
	  }
	  else if (left instanceof HLNumber && right instanceof HLNumber) {
		  return ((HLNumber)left).isLessThan((HLNumber)right);
	  }
	  return false;
  }

  public Object visit(ASTLESSEQ node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);

	  if (left instanceof HLSet && right instanceof HLSet) {
		  return ((HLSet)left).isLessThan((HLSet)right) || ((HLSet)left).isSame((HLSet)right);
	  }
	  else if (left instanceof HLNumber && right instanceof HLNumber) {
		  return ((HLNumber)left).isLessThanOrEqualTo((HLNumber)right);
	  }
	  return false;
  }

  public Object visit(ASTGREATER node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);

	  if (left instanceof HLSet && right instanceof HLSet) {
		  return ((HLSet)right).isLessThan((HLSet)left);
	  }
	  else if (left instanceof HLNumber && right instanceof HLNumber) {
		  return ((HLNumber)left).isGreaterThan((HLNumber)right);
	  }
	  return false;
  }

  public Object visit(ASTGREATEQ node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);

	  if (left instanceof HLSet && right instanceof HLSet) {
		  return ((HLSet)right).isLessThan((HLSet)left) || ((HLSet)left).isSame((HLSet)right);
	  }
	  else if (left instanceof HLNumber && right instanceof HLNumber) {
		  return ((HLNumber)left).isGreaterThanOrEqualTo((HLNumber)right);
	  }
	  return false;
  }

  public Object visit(ASTEQUAL node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);
	  
	  if (left instanceof HLNumber && right instanceof HLNumber) {
		  return ((HLNumber)left).isSame((HLNumber)right);
	  }
	  else if (left instanceof HLSet && right instanceof HLSet) {
		  return ((HLSet)left).isSame((HLSet)right);
	  }
	  return false;
  }

  public Object visit(ASTNOTEQ node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);
	  
	  if (left instanceof HLNumber && right instanceof HLNumber) {
		  return !((HLNumber)left).isSame((HLNumber)right);
	  }
	  else if (left instanceof HLSet && right instanceof HLSet) {
		  return !((HLSet)left).isSame((HLSet)right);
	  }
	  return false;
  }

  public Object visit(ASTISIN node, Object data) throws Exception{
	  Object elem = node.jjtGetChild(0).jjtAccept(this, data);
	  Object set = node.jjtGetChild(1).jjtAccept(this, data);

	  if (elem instanceof HLNumber && set instanceof HLSet) {
		  boolean result = ((HLSet)set).contains((HLNumber)elem);
		  return result;
	  }
	  return false;
  }

  public Object visit(ASTNOTIN node, Object data) throws Exception{
	  Object elem = node.jjtGetChild(0).jjtAccept(this, data);
	  Object set = node.jjtGetChild(1).jjtAccept(this, data);

	  if (elem instanceof HLNumber && set instanceof HLSet) {
		  boolean result = !((HLSet)set).contains((HLNumber)elem);
		  return result;
	  }
	  return true;
  }

  // Handles addition and set union
  // Update sum visitor to handle null values
  public Object visit(ASTsum node, Object data) throws Exception{
	  Object result = node.jjtGetChild(0).jjtAccept(this, data);

	  if (result == null && node.jjtGetChild(0) instanceof ASTidentifier) { result = new HLNumber(0); }

	  for (int i = 1; i < node.jjtGetNumChildren(); i++) {
		  Object nextOperand = node.jjtGetChild(i).jjtAccept(this, data);

		  if (nextOperand == null && node.jjtGetChild(i) instanceof ASTidentifier) { nextOperand = new HLNumber(0); }

		  // Check if this is actually a negative operand
		  boolean isNegative = false;
		  if (nextOperand instanceof HLSet) {
			  SimpleNode childNode = (SimpleNode)node.jjtGetChild(i);
			  isNegative = (childNode instanceof ASTneg);
		  }
		  if (result instanceof HLSet && nextOperand instanceof HLSet) {
			  if (isNegative) {
				  // Set difference
				  result = ((HLSet)result).sub((HLSet)nextOperand);
			  }
			  else {
				  // Set union
				  result = ((HLSet)result).add((HLSet)nextOperand);
			  }
		  }
		  else if (result instanceof HLNumber && nextOperand instanceof HLNumber) {
			  if (isNegative) {
				  result = ((HLNumber)result).sub((HLNumber)nextOperand);
			  }
			  else {
				  result = ((HLNumber)result).add((HLNumber)nextOperand);
			  }  
		  }
	  }
	  return result;
  }

  // Handles negation for both numbers and sets
  public Object visit(ASTneg node, Object data) throws Exception{
	  Object operand = node.jjtGetChild(0).jjtAccept(this, data);
	  
	  if (operand instanceof HLSet) {
		  SimpleNode parent = (SimpleNode)node.jjtGetParent();
		  // If parent is ASTsum, this is part of subtraction
		  if (parent instanceof ASTsum && parent.jjtGetNumChildren() > 1) {
			  return operand;
		  }
		  // Otherwise it's unary negation
		  else {
			  return ((HLSet)operand).negate();
		  }

	  }
	  else if (operand instanceof HLNumber) {
		  return ((HLNumber)operand).negate();
	  }
	  return null;
  }

  public Object visit(ASTpos node, Object data) throws Exception{
	  return node.jjtGetChild(0).jjtAccept(this, data);
  }

  public Object visit(ASTmul node, Object data) throws Exception{
	  Object left = node.jjtGetChild(0).jjtAccept(this, data);
	  Object right = node.jjtGetChild(1).jjtAccept(this, data);

	  if (left instanceof HLNumber && right instanceof HLNumber) {
		  return ((HLNumber)left).mul((HLNumber)right);
	  }
	  else if (left instanceof HLSet && right instanceof HLSet) {
		  return ((HLSet)left).mul((HLSet)right);
	  }
	  return null;
  }

  public Object visit(ASTdiv node, Object data) throws Exception{
	  HLNumber left = (HLNumber)node.jjtGetChild(0).jjtAccept(this, data);
	  HLNumber right = (HLNumber)node.jjtGetChild(1).jjtAccept(this, data);
	  return left.div(right);
  }

  public Object visit(ASTmod node, Object data) throws Exception{
	  HLNumber left = (HLNumber)node.jjtGetChild(0).jjtAccept(this, data);
	  HLNumber right = (HLNumber)node.jjtGetChild(1).jjtAccept(this, data);
	  return left.mod(right);
  }

  public Object visit(ASTAbsolute_value node, Object data) throws Exception{
	  Object value = node.jjtGetChild(0).jjtAccept(this, data);
	  if (value instanceof HLNumber) {
		  int num = ((HLNumber)value).value;
		  return new HLNumber(Math.abs(num));
	  }
	  else if (value instanceof HLSet) {
		  return ((HLSet)value).card();
	  }
	  return null;
  }

  public Object visit(ASTinterval node, Object data) throws Exception{
	  HLNumber start = (HLNumber)node.jjtGetChild(0).jjtAccept(this, data);
	  HLNumber end = (HLNumber)node.jjtGetChild(1).jjtAccept(this, data);
	  return new HLSet(start, end);
  }

  // Update set former visitor
  public Object visit(ASTset_former node, Object data) throws Exception{
	  // Get the bound variable identifier
	  ASTidentifier boundVar = (ASTidentifier)node.jjtGetChild(0);
	  Integer boundVarKey = (Integer)boundVar.jjtGetValue();

	  // Get the set to iterate over
	  Object setExpr = node.jjtGetChild(1).jjtAccept(this, data);
	  if (!(setExpr instanceof HLSet)) {
		  throw new EvaluationException("Set former requires a set to iterate over");
	  }
	  HLSet sourceSet = (HLSet)setExpr;

	  // Create result set
	  HLSet resultSet = new HLSet();

	  // Create activation for set former scope
	  HLActivation setFormerScope = new HLActivation(HLActivation.getCurrentActivation());

	  try {
		  // For each element in source set
		  for (Object elem : sourceSet.getElements()) {
			  // Bind the variable in the set former scope
			  HLSymbTab entry = new HLSymbTab(boundVarKey, "typenum");
			  entry.setValue(elem);
			  setFormerScope.addVariable(entry);

			  // Evaluate condition
			  boolean matchesCondition = false;
			  if (node.jjtGetNumChildren() > 2) {
				  SimpleNode condition = (SimpleNode)node.jjtGetChild(2);
				  Object condResult = condition.jjtAccept(this, data);
				  if (condResult instanceof Boolean) {
					  matchesCondition = (Boolean)condResult; // If condition is true, we want to exclude
				  }
			  }

			  // Add element to result set if it matches the condition
			  if (matchesCondition && elem instanceof HLNumber) {
				  resultSet.add((HLNumber)elem);
			  }
		  }
		  // Since we want to remove these elements from the original set
		  return sourceSet.sub(resultSet);
	  }
	  finally {
		  setFormerScope.pop();
	  }
  }

  // Set creation
  public Object visit(ASTset node, Object data) throws Exception{
	  TreeSet<HLNumber> elements = new TreeSet<>();

	  for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		  Object value = node.jjtGetChild(i).jjtAccept(this, data);
		  if (value instanceof HLNumber) {
			  elements.add((HLNumber)value);
		  }
	  }

	  return new HLSet(elements);
  }

  // Update identifier visitor to handle variable references
  public Object visit(ASTidentifier node, Object data) throws Exception{
	  // Get identifier key and look up current value
	  Integer idKey = (Integer)node.jjtGetValue();
	  return HLSymbTab.getVariableValue(idKey);
  }

  public Object visit(ASTtypenum node, Object data) throws Exception{
    return defaultVisit(node, data);
  }

  public Object visit(ASTtypeset node, Object data) throws Exception{
    return defaultVisit(node, data);
  }

  public Object visit(ASTtypebool node, Object data) throws Exception{
    return defaultVisit(node, data);
  }

  // Number creation
  public Object visit(ASTnumber node, Object data) throws Exception{
	  Object value = node.jjtGetValue();

	  if (value instanceof String) {
		  return new HLNumber(Integer.parseInt((String)value));
	  }
	  else if (value instanceof Integer) {
		  return new HLNumber((Integer)value);
	  }
	  return null;
  }

  public Object visit(ASTstring node, Object data) throws Exception{
	  return (String)node.jjtGetValue();
  }
}
/* JavaCC - OriginalChecksum=5fed741071bb7da1c3cb2cfb13af7ff9 (do not edit this line) */
